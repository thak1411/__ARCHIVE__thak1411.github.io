---
layout: post
title: "Codeforces Round #690 (Div. 3) - Virtual"
date: 2021-01-23 00:03:00 +0900
category:
 - Algorithm
 - CodeForces
---
<script type="text/javascript" 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
<center>
<div markdown="1">
[ 대회 정보 ](https://codeforces.com/contest/1462) / [ 정답 코드 ](https://github.com/thak1411/rn-algo-set/tree/main/src/CF_690_DIV3_VIR)
</div>
</center>

# A. Favorite Sequence

처음에 해석을 잘못해서 뇌절할 뻔..  
$$b_{i*2} = a_i$$  
$$b_{i*2+1} = a_{n - i - 1}$$  
이 두 식으로 b를 만들면 된다. 다른 사람들은 덱을 이용해 앞뒤로 꼽은 것 같다.

# B. Last Year's Substring

앞에서 2020을 몇글자까지 읽는지, 뒤에서 0202를 몇글자까지 읽는지 센 뒤 4글자 이상 읽어지면 정답이다.  
다른사람들은 문자열 앞뒤를 잘라서 만들어보는식으로 풀이를 했는데 이게 더 간단한 것 같다.

# C. Unique Number

$$1$$ ~ $$50$$ 까지에 쉬운 문제라 손으로 풀 수도 있다.  
백트래킹으로 문제를 풀었지만, $$10! * 50$$ 인줄 알고 시간초과가 나지 않을까 생각했지만, $$9! * 50$$이라 상관없었을 것 같다.  
백트래킹으로 구한 답을 디비로 밀어넣고 AC를 받았다.

# D. Add to Neighbour and Remove

특정한 값을 구해놓고 그 값으로 만들어내는 풀이 일 것이라고 생각되는 문제다.  
이런 류의 문제는 파라메트릭 서치가 많은데 이 문제의 그래프는 모노토닉하지 않기 때문에 파라메트릭 서치는 아니다.  
그리고 $$N$$의 범위가 $$3000$$이하인 것을 보고 바로 $$O(N^2)$$ 풀이를 떠올렸다.  

처음엔 $$a_i$$중 하나로 만드는 문제라고 생각했지만, 조금만 생각해도 반례가 있었다.  
그리고 생각했던 접근은 처음 수 ~ 특정 수 구간이 정답에서 맨 왼쪽 부분을 차지한다는 특징을 이용한 풀이였다.  
$$1$$ ~ $$N$$ 까지의 모든 구간합에 대해서 그 구간합으로 이루어진 그룹의 수를 $$x$$라고 하면 $$N - x$$중 가장 작은 수가 정답이 된다. 즉 구간을 제일 많이 만드는 것이 정답이다.  
이 때 내가 생각하지 못했던 부분이 있었다. 구간을 계속 더하다가 구간합보다 커지게 되면 모든 수를 그 구간합으로 만들 수는 없다는 소리다. 하지만 다 더하다가 구간합이 되지 않아도 모든 수를 그 구간합으로 만들 수 없다는 소리다. 하지만 이 부분을 체크하지 못하고 ( 구현실수로 ) 계속 맞왜틀을 외치다 패널티를 많이 받았다. 이 부분이 좀 아쉬웠다.

# E. Close Tuples

보자마자 풀이를 떠올렸지만, 구현하면서 뇌절을 많이 한 문제다.  
투포인터는 항상 구현하면서 뇌절을 많이 하는 것 같다. 연습 좀 해야 할 것 같다. 그리고 여기선 투포인터 대신에 upper_bound 를 사용했으면 더 깔끔했을것이다.  
구간에서 $$max - min \le k$$ 인 $$m$$개 원소를 선택하는 모든 경우의 수를 세는 문제이다.  
핵심 아이디어는 간단하다. 모든 수는 정렬되어있다고 가정한다. 하나의 값에 대해 이 값이 $$max - min \le k$$를 만족하는 수열을 고를 때 몇번째 수 까지 고를 수 있는지 combination을 이용해 구하는 것이다.  
예를 들어 $$1, 2, 3, 3, 5, 5, 6$$ 이 있고 $$k = 2$$ 라고 한다면 $$1$$에서는 $$1, 2, 3, 3$$ 즉 4개를 선택할 수 있다. 이 때 $$m = 2$$라고 하면 $$1$$을 포함하고 조건을 만족하며 고를 수 있는 경우의 수는 $$4C2$$가 되는 것이다. 하지만 여기서 중복으로 세어지는 경우가 있다. 바로 $$2$$를 포함하여 경우의 수를 세어보자.  
$$2$$에서는 $$2, 3, 3$$즉 3개를 고를 수 있다. 여기서 $$3C2$$를 결괏값에 더해야 한다고 생각되지만, 사실은 이 $$2, 3, 3$$은 앞에서 세어준 경우에 포함되어있는 경우다. 따라서 이런 경우는 세어주면 안된다. 하지만 여기서 또 생각해야 할 점이 이전에 세어줬던 구간에 +로 새로운 구간이 있을 수 있다. 앞의 수열에서 $$4$$가 포함되어있다면, $$2, 3, 3, 4$$를 고를 수 있을 것이다. 따라서 여기서는 $$4C2 - 3C2$$를 통해 중복 없이 구간을 셀 수 있다. ( 셀 수 있는 경우의수 - 이미 센 경우의수는 빼기 )  
이런식으로 현재 수에서 $$max - min \le k$$인 조건을 만족하는 구간을 미리 전처리 한뒤 위의 식으로 모든 경우의 수를 세어주면 된다.

<br /><br />  

오늘도 즐겜 풀이를 했다. 심지어 파파고를 한번도 켜지 않고 문제들을 풀었다.  
그래서 참 의미있는 셋인 것 같다. 실력에 연연하지 않고 재미로 문제들을 풀었다. 문제들이 너무 쉬운 셋이라 나름 쉽게 풀린 셋들이다.  
그래서 꽤 많이 푼 것 치곤 등수가 낮았지만 ( 패널티 관리를 잘못함 ) 나름 재밌게 풀었다.  
실수를 더더욱 줄이고 간결한 코드들을 만드는 것이 좋을 것 같다.